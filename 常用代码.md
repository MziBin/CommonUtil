# 常用代码

## 1.跨线程更新UI操作和多线程操作

```csharp
private void btn02_Click(object sender, EventArgs e)
{
    Task task = new Task(() =>
    {
        while (true)
        {
            if(txt02.InvokeRequired)
            {
                //txt02.Invoke(new Action(() =>
                //{
                //    txt02.Text = (Convert.ToInt32(txt02.Text) + 1).ToString();
                //}));
                //txt02.Invoke(new Action(UpdateTxt02));
                txt02.Invoke(new Action<string>(UpdateTxt02), (Convert.ToInt32(txt02.Text) + 1).ToString());
                System.Threading.Thread.Sleep(1000);
            }

        }
    });
    task.Start();
}

private void UpdateTxt02()
{
    txt02.Text = (Convert.ToInt32(txt02.Text) + 1).ToString();
}

private void UpdateTxt02(string count)
{
    txt02.Text = count;
}
```

## 2.响应UI界面

```csharp
Application.DoEvents();
单线程场景下临时保持 UI 响应的 “权宜之计”，通过强制处理消息队列让界面 “不冻结”；但由于存在重入风险和性能问题，现代应用更推荐用多线程 / 异步编程 从根本上避免 UI 线程阻塞
```

## 3.换行符

```csharp
System.Environment.NewLine
```

## 4.获取当前日期格式化字符串

```csharp
DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff")
```

## 5.获取当前程序的目录

```csharp
System.IO.Directory.GetCurrentDirectory();//相当于当前bin|debug|
```

## 6.队列

```csharp
//创建队列,T就是要存入队列中的数据对象，可以自定义为任意类结构存储数据到队列
private ConcurrentQueue<T> queue = new ConcurrentQueue<T>();
//存入
queue.Enqueue(obj);
//取出，数据在obj中
queue.TryDequeue(out obj);
```

## 7.并行遍历

```csharp
 // 准备数据源（1000个整数）
        var numbers = new List<int>();
        for (int i = 0; i < 1000; i++) numbers.Add(i);

        // 并行遍历
        Parallel.ForEach(numbers, num =>
        {
            int square = num * num; // 计算平方（CPU密集型操作）
            Console.WriteLine($"数字 {num} 的平方是 {square}，处理线程：{System.Threading.Thread.CurrentThread.ManagedThreadId}");
        });

        Console.WriteLine("遍历完成");
```



## 8.栈

```csharp
// 1. 创建一个int类型的栈
        Stack<int> stack = new Stack<int>();

        // 2. 入栈（Push）：元素依次添加到栈顶
        stack.Push(10);  // 栈：[10]（栈顶是10）
        stack.Push(20);  // 栈：[10, 20]（栈顶是20）
        stack.Push(30);  // 栈：[10, 20, 30]（栈顶是30）
        Console.WriteLine($"栈中元素数量：{stack.Count}"); // 输出：3

        // 3. 查看栈顶（Peek）：不移除元素
        int top = stack.Peek();
        Console.WriteLine($"栈顶元素：{top}"); // 输出：3（栈仍为[10,20,30]）

        // 4. 出栈（Pop）：移除并返回栈顶元素
        int popped = stack.Pop();
        Console.WriteLine($"出栈元素：{popped}"); // 输出：3
        Console.WriteLine($"出栈后栈顶：{stack.Peek()}"); // 输出：2（栈变为[10,20]）

        // 5. 判断是否包含元素
        bool has10 = stack.Contains(10);
        Console.WriteLine($"栈中是否包含10：{has10}"); // 输出：True

        // 6. 清空栈
        stack.Clear();
        Console.WriteLine($"清空后元素数量：{stack.Count}"); // 输出：0
```







## 9.list列表复制避免改变原值

Tolist()和opy2 = new List<int>(ori都是浅复制，引用类型的还是会变，基本数据类型不会变

```csharp
// 原列表（元素为值类型 int）
List<int> original = new List<int> { 1, 2, 3 };

// 方法1：ToList()
List<int> copy1 = original.ToList();

// 方法2：List构造函数
List<int> copy2 = new List<int>(original);

// 方法3：GetRange
List<int> copy3 = original.GetRange(0, original.Count);

// 修改新列表，原列表不受影响
copy1[0] = 100;
Console.WriteLine(original[0]); // 输出：1（原列表未变）
```





## 10.Task使用令牌取消和开始

```csharp
// 不要用静态cts，改为局部变量或实例变量，每次启动时新建
private CancellationTokenSource cts;
private bool isRunning = false; // 用更清晰的变量名表示“是否正在运行”
private Task currentTask; // 保存当前运行的Task，便于等待或处理
private void btn03_Click(object sender, EventArgs e)
{
    if (!isRunning)
    {
        // 1. 每次启动时创建新的取消令牌源
        cts = new CancellationTokenSource();
        CancellationToken token = cts.Token;

        // 2. 启动Task，保存到currentTask
        currentTask = Task.Run(async () =>
        {
            try
            {
                while (true)
                {
                    // 【关键】先检查取消，优先响应取消请求
                    token.ThrowIfCancellationRequested();

                    // 更新UI（确保在UI线程）
                    if (txt03.InvokeRequired)
                    {
                        txt03.Invoke(new Action(() =>
                        {
                            // 简化逻辑：直接在Invoke中处理数值累加
                            if (int.TryParse(txt03.Text, out int num))
                                txt03.Text = (num + 1).ToString();
                            else
                                txt03.Text = "1";
                        }));
                    }

                    // 【关键】Delay传入token，允许中途被取消
                    await Task.Delay(1000, token);
                }
            }
            catch (OperationCanceledException)
            {
                // 捕获取消异常，正常退出，不做处理（或记录日志）
                Console.WriteLine("Task已被取消");
            }
        }, token);

        isRunning = true;
        btn03.Text = "取消"; // 按钮文本提示当前状态
    }
    else
    {
        // 3. 取消Task
        if (cts != null)
        {
            cts.Cancel(); // 发送取消请求
            cts.Dispose(); // 释放资源
            cts = null;
        }
        isRunning = false;
        btn03.Text = "启动";
    }
}
```

## 11.同步锁

```
// 定义一个专用的锁对象（必须是引用类型，且为静态以保证全局唯一）
private static readonly object _lockObj = new object();
private int _sharedValue = 0; // 共享资源

// 多线程访问的方法
public void IncrementValue()
{
    // lock块内的代码同一时间只能被一个线程执行
    lock (_lockObj)
    {
        _sharedValue++; // 临界区：操作共享资源
        Console.WriteLine($"当前值：{_sharedValue}，线程ID：{Thread.CurrentThread.ManagedThreadId}");
    }
}
```

## 12.Thread使用

```csharp
Thread thread;
thread = new Thread(new ThreadStart(Timer4Worker));
thread.IsBackground = true;



bool isTimer4Running = false;

private void btn04_Click(object sender, EventArgs e)
{
    if (!isTimer4Running)
    {
        //Thread thread = new Thread(() =>
        //{
        //    while (true)
        //    {
        //        if (txt04.InvokeRequired)
        //        {
        //            txt04.Invoke(new Action(() =>
        //            {
        //                if (int.TryParse(txt04.Text, out int num))
        //                    txt04.Text = (num + 1).ToString();
        //                else
        //                    txt04.Text = "1";
        //            }));
        //        }
        //        Thread.Sleep(1000);
        //    }
        //});
        isTimer4Running = true;
        if(thread.ThreadState == ThreadState.Aborted)
        {
            thread = new Thread(new ThreadStart(Timer4Worker));
        }
        thread.Start();
    }
    else
    {
        isTimer4Running = false;
        thread.Abort();
    }
}


private void Timer4Worker()
{
    while (true)
    {
        if (txt04.InvokeRequired)
        {
            txt04.Invoke(new Action(() =>
            {
                if (int.TryParse(txt04.Text, out int num))
                    txt04.Text = (num + 1).ToString();
                else
                    txt04.Text = "1";
            }));
        }
        Thread.Sleep(1000);
    }
}
```


